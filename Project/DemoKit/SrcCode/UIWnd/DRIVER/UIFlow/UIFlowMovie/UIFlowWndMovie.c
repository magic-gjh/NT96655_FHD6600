//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndMovieRes.c"
#include "UIFlow.h"
#include "Audio.h"
#include "ide.h"
#include "md_api.h"
#include "IPL_CBMsg.h"
#include "FileSysTsk.h"
#include "MediaRecAPI.h"
#include "IPL_Ctrl.h" // Isiah, implement YUV merge mode of recording func.
#include "ldws_nvt_lib.h"
#include "Rtc.h"
#if USE_FILEDB
#include "FileDB.h"
#include "namerule_fileDB.h"
#endif
#include "UIFlow.h"
#include "GSensor.h"
#include "Timer.h"
#include "Uart.h"
#define __MODULE__          UIFlowWndMovie
//#define __DBGLVL__ 0        //OFF mode, show nothing
//#define __DBGLVL__ 1        //ERROR mode, show err, wrn only
#define __DBGLVL__ 2        //TRACE mode, show err, wrn, ind, msg and func and ind, msg and func can be filtering by __DBGFLT__ settings
#define __DBGFLT__ "*"      //*=All
#include "DebugModule.h"
//---------------------UIFlowWndMovieCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_camera)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_CyclicRec)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MotionDet)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_battery)
CTRL_LIST_ITEM(UIFlowWndMovie_YMD_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Storage)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_time)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_maxtime)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_resolution)
CTRL_LIST_ITEM(UIFlowWndMovie_Zoom_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_HDR)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticIcon_PIMC)

CTRL_LIST_ITEM(UIFlowWndMovie_Status_GPS)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Gsensor)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_Lock)

CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_Audio)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticTXT_Speed)
CTRL_LIST_ITEM(UIFlowWndMovie_LDWS_Frame)
CTRL_LIST_END

//----------------------UIFlowWndMovieCtrl Event---------------------------
INT32 UIFlowWndMovie_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieWrError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnPreviewStable(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACPlug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACUnplug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_GsensorTrig(VControl *, UINT32, UINT32 *);

EVENT_BEGIN(UIFlowWndMovie)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndMovie_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndMovie_OnClose)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndMovie_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndMovie_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndMovie_OnKeyDown)
EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndMovie_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndMovie_OnKeyRight)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndMovie_OnChildClose)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndMovie_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndMovie_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndMovie_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndMovie_OnKeyPlayBack)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndMovie_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW,UIFlowWndMovie_OnBatteryLow)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndMovie_OnKeyMode)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_FINISH,UIFlowWndMovie_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_ONE_SEC,UIFlowWndMovie_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_OVERTIME,UIFlowWndMovie_OnMovieFull) // the same handling as storage full (may need to show special message)
EVENT_ITEM(NVTEVT_CB_MOVIE_FULL,UIFlowWndMovie_OnMovieFull)
EVENT_ITEM(NVTEVT_CB_MOVIE_WR_ERROR,UIFlowWndMovie_OnMovieWrError)
EVENT_ITEM(NVTEVT_CB_MOVIE_SLOW,UIFlowWndMovie_OnStorageSlow)
EVENT_ITEM(NVTEVT_CB_MOVIE_LOOPREC_FULL,UIFlowWndMovie_OnLoopRecFull)
//EVENT_ITEM(IPL_CBMSG_PREVIEWSTABLE,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CALLBACK,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG,UIFlowWndMovie_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_ZOOM,UIFlowWndMovie_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndMovie_OnStorageChange)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndMovie_OnTimer)
EVENT_ITEM(NVTEVT_AC_Plug,UIFlowWndMovie_OnACPlug)
EVENT_ITEM(NVTEVT_AC_UnPlug,UIFlowWndMovie_OnACUnplug)
EVENT_ITEM(NVTRET_PROTECT,UIFlowWndMovie_GsensorTrig)

EVENT_END 

// Isiah, implement YUV merge mode of recording func.
extern void Movie_IPLChangeCB(UINT32 mode, UINT32 param);

// Movie mode key mask
#define MOVIE_KEY_PRESS_MASK        (FLGKEY_KEY_MASK_DEFAULT)
#define MOVIE_KEY_RELEASE_MASK      (FLGKEY_UP | FLGKEY_DOWN)
#define MOVIE_KEY_CONTINUE_MASK     (FLGKEY_UP | FLGKEY_DOWN | FLGKEY_ENTER | FLGKEY_MODE)
#define MOVIERECORD_KEY_PRESS_MASK  (FLGKEY_UP | FLGKEY_DOWN | FLGKEY_ENTER | FLGKEY_MODE)
//-----------------------------------------------------------------------------------------
//static BOOL    g_uiRecordIngMotionDet = TRUE;
static UINT32  gUIMotionDetTimerID = NULL_TIMER;
static UINT32  g_uiDateTimerID = NULL_TIMER;
static UINT32 g_uiMaskKeyPress      = MOVIE_KEY_PRESS_MASK;
static UINT32 g_uiMaskKeyRelease    = MOVIE_KEY_RELEASE_MASK;
//static UINT32 g_uiMaskKeyContinue   = MOVIE_KEY_CONTINUE_MASK;
static volatile BOOL g_bRedLEDOn = FALSE;
static volatile BOOL g_ACPlug = FALSE;
static volatile BOOL g_PreviewStable = FALSE;
static volatile BOOL g_PreviewStable_Record = FALSE;
BOOL g_bSpeLockFun = FALSE;
static volatile UINT32  DetLDWS_BEEPTimerID;// */ms
void System_LDWS_BEEP(UINT32 uiEvent);
_ALIGNED(4)  GPSDATA gpsdata={0};

BOOL g_bgsensor = FALSE;

static CHAR  Speed_buf[20];
UINT32 uiSpeed = 0;
UINT32 uiSpeedKM = 0;
//extern BOOL ACCON2OFF;
static BOOL gbUpdteGPSTime=FALSE;
extern int SX_TIMER_DET_TV_ID;
BOOL gbFileSystemStatus=TRUE;


BOOL System_OnStrgIsFileSystemOK(void)
{
    FST_FILE    pFile;
    char        *fileName;

     fileName = "A:\\test.txt";    
     pFile = FileSys_OpenFile(fileName, FST_CREATE_ALWAYS|FST_OPEN_WRITE);

    if (pFile == NULL)
    {
        debug_msg("open file error\r\n");
        gbFileSystemStatus= FALSE;
    }
    else
    {
        debug_msg("open test file ok\r\n");
    
         FileSys_CloseFile(pFile);        
         FileSys_DeleteFile(fileName);
    }        
        return gbFileSystemStatus;
}

BOOL System_OnStrgIsGetFileSystemStatus(void)
{
        return gbFileSystemStatus;
}

void UIFlowwndMovieUpdateGPSTime()
{			
       UINT32 day = 0, month = 0, year = 0, hour = 0, min = 0, sec = 0;
	UINT8	uiTimeZone = 0;
       RTC_DATE rtcDate;
       UINT32 Days;
       
	//if (uiPreGPSStatus != GPSStatus)
	{
		debug_msg("###Set date time by GPS (Greenwich)(%04d/%d/%d,%d:%d:%d).    ###\r\n",RMCInfo.Year, RMCInfo.Month, RMCInfo.Day, RMCInfo.Hour, RMCInfo.Minute, RMCInfo.Second);
		day = RMCInfo.Day;
		month = RMCInfo.Month;
		year = RMCInfo.Year;
		hour = RMCInfo.Hour;
		min = RMCInfo.Minute;
		sec = RMCInfo.Second;
        
              rtcDate=rtc_getDate();
		//rtcDate.s.year = year+2000;
		//rtcDate.s.month = month;
		//rtcDate.s.day = day;
		Days = rtc_convertDate2Days(rtcDate);
				
		uiTimeZone = SysGetFlag(FL_AUTO_UPDATE_TIME);//(FL_TIME_ZONE);
		switch (uiTimeZone)
		{
			case TIME_ZONE_GMTM12:
			case TIME_ZONE_GMTM11:
			case TIME_ZONE_GMTM10:
			case TIME_ZONE_GMTM9:
			case TIME_ZONE_GMTM8:
			case TIME_ZONE_GMTM7:
			case TIME_ZONE_GMTM6:
			case TIME_ZONE_GMTM5:
				if(hour<(13-uiTimeZone))
				{
					hour=24+hour-(13-uiTimeZone);
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=(13-uiTimeZone);
				}
				break;									
			case TIME_ZONE_GMTM4:
				if(hour<(13-uiTimeZone+1))
				{
					hour=24+hour-(13-uiTimeZone+1);
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=(13-uiTimeZone+1);
				}
				break;									
			case TIME_ZONE_GMTM3:
			case TIME_ZONE_GMTM2:
			case TIME_ZONE_GMTM1:
				
				if(hour<(13-uiTimeZone+2))
				{
					hour=24+hour-(13-uiTimeZone+2);
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=(13-uiTimeZone+2);
				}
				break;
			case TIME_ZONE_GMTM430:
				if(min<30)
				{
				       if(hour>0){
					hour-=1;
					min+=30;}
					  else{
					Days-=1;
					hour=23;
					min+=30;}
					
				}
				else
				{
					min-=30;
				}
				if(hour<4)
				{
					hour=24+hour-4;
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=4;
				}									
				break;
			case TIME_ZONE_GMTM330:
				if(min<30)
				{
				       if(hour>0){
					hour-=1;
					min+=30;}
					  else{
					Days-=1;
					hour=23;
					min+=30;}
					
				}
				else
				{
					min-=30;
				}
				if(hour<3)
				{
					hour=24+hour-3;
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=3;
				}									
				break;									
			case TIME_ZONE_GMT1:
				hour += 1;
				break;
			case TIME_ZONE_GMT2:
				hour += 2;
				break;
			case TIME_ZONE_GMT3:
				hour += 3;
				break;							
			case TIME_ZONE_GMT330:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 4;
				}
				else
				{
					hour += 3;
				}
				break;
			case TIME_ZONE_GMT4:
				hour += 4;
				break;							
			case TIME_ZONE_GMT430:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 5;
				}
				else
				{
					hour += 4;
				}
				break;
			case TIME_ZONE_GMT5:
				hour += 5;
				break;
			case TIME_ZONE_GMT530:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 6;
				}
				else
				{
					hour += 5;
				}
				break;											
			case TIME_ZONE_GMT545:
				min += 45;
				if (min >= 60)
				{
					min -= 60;
					hour += 6;
				}
				else
				{
					hour += 5;
				}
				break;
			case TIME_ZONE_GMT6:
				hour += 6;
				break;
			case TIME_ZONE_GMT630:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 7;
				}
				else
				{
					hour += 6;
				}
				break;										
			case TIME_ZONE_GMT7:
				hour += 7;
				break;
			case TIME_ZONE_GMT8:
				hour += 8;
				break;
			case TIME_ZONE_GMT9:
				hour += 9;
				break;
			case TIME_ZONE_GMT930:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 10;
				}
				else
				{
					hour += 9;
				}
				break;
			case TIME_ZONE_GMT10:
				hour += 10;
				break;
			case TIME_ZONE_GMT11:
				hour += 11;
				break;
			case TIME_ZONE_GMT12:
				hour += 12;
				break;		
			case TIME_ZONE_GMT13:
				hour += 13;
				break;										
			default:
				break;									
		}
		if (hour >= 24)
		{
			hour -= 24;
			day ++;
			if ((month == 4) || (month == 6) || (month == 9) || (month == 11))
			{
				if (day > 30)
				{
					day = 1;
					month ++;
				}
			}
			else if ((month == 1) || (month == 3) || (month == 5) || (month == 7) || (month == 8) || (month == 10))
			{
				if (day > 31)
				{
					day = 1;
					month ++;
				}
			}
			else if (month == 12)
			{
				if (day > 31)
				{
					year ++;
					day = 1;
					month = 1;
				}
			}
			else if (month == 2)
			{
				if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0))
				{
					if (day > 29)
					{
						month ++;
						day = 1;
					}
				}
				else
				{
					if (day > 28)
					{
						month ++;
						day = 1;
					}
				}
			}
		}		
		debug_msg("###Set date time by GPS (BeiJing)(%04d/%d/%d,%d:%d:%d).    ###\r\n",year, month, day, hour, min, sec);
		rtc_setDate(year+2000, month, day);
	       rtc_setTime(hour, min, sec);
	       rtc_triggerCSET();           
	}
}

void FlowMovie_IconDrawSpeed()
{
    sprintf(Speed_buf,"%03d Km/h",uiSpeedKM);
    //sprintf(Speed_buf,"%03d Mile/h",uiSpeed);
    UxStatic_SetData(&UIFlowWndMovie_StaticTXT_SpeedCtrl,STATIC_VALUE,Txt_Pointer(Speed_buf));
    UxCtrl_SetShow(&UIFlowWndMovie_StaticTXT_SpeedCtrl,TRUE);	
}

void FlowMovie_IconHideSpeed()
{
sprintf(Speed_buf,"0 Km/h",uiSpeedKM);
UxStatic_SetData(&UIFlowWndMovie_StaticTXT_SpeedCtrl,STATIC_VALUE,Txt_Pointer(Speed_buf));
    //UxCtrl_SetShow(&UIFlowWndMovie_StaticTXT_SpeedCtrl,TRUE);	
    UxCtrl_SetShow(&UIFlowWndMovie_StaticTXT_SpeedCtrl,FALSE);
}


BOOL UIFlowWndMovie_IsGsensorTrig(void)
{
	return g_bgsensor;
}
void UIFlowWndMovie_SetGsensorTrigFlag(BOOL En)
{
	g_bgsensor=En;
}
#if (USE_FILEDB==DISABLE)
static void UIFlowWndMovie_DeleteEmptyFolder(void)
{
 SDCFDIRINFO dirinfo;
 char   path[DCF_FULL_FILE_PATH_LEN];
 UINT32 uiMaxFolderID,uiPrevMaxFolderID;
 UINT32 uiStrlen;
 BOOL ret;


    uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);
    // check if folder has file
    ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);
    if (ret)
    {
        while (dirinfo.uiNumOfDcfObj==0)
        {
            DCF_GetDirPath(uiMaxFolderID,path);
            uiStrlen = strlen(path);
            path[uiStrlen-1] = '\0';
            if (FileSys_DeleteDir(path) != FST_STA_OK)
            {
                debug_msg("FileSys_DeleteDir failed\r\n");
            }

            DCF_Refresh();

            uiPrevMaxFolderID = uiMaxFolderID;
            // search another Max Empty folder ID
            uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);

            // break if getting max folder id is always same
            if (uiPrevMaxFolderID == uiMaxFolderID)
                break;
            // check if folder has file
            ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);

            if (ret==FALSE)
              break;
        }
    }
}
#endif

static void Filesys_dirCB(FIND_DATA *findDir, BOOL *bContinue, UINT16 *cLongname, UINT32 Param)
{
    *bContinue = TRUE;
}
INT32 UIFlowWndMovie_OnExeRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiKeyAct;
 UINT32 uiState;
 BOOL   CheckStorageErr = FALSE;


    // flush key event first
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

    // if HDMI is inserted, 128MB buffer is not enough for movie recording
    if (KeyScan_GetPlugDev() == PLUG_HDMI)
    {
        //return NVTEVT_CONSUME;
    }
    if(System_OnStrgIsFileSystemOK()==FALSE)
    {
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARDERROR,FLOWWRNMSG_TIMER_2SEC);
        return NVTEVT_CONSUME;
    }
    
    if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
    {
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
        return NVTEVT_CONSUME;
    }

    if (paramNum>=3)
    {
        uiState = paramArray[2];
    } else {
        uiState = 0;
    }

    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
            if (MediaRec_GetStatus() == MEDIAREC_STATUS_OPENED_NOT_RECORD)
            {
                gMovData.State= MOV_ST_REC;
                //#NT#2013/1/28#Philex Lin - begin
                // fix bug that can't record in cyclic and card full case
                if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
                {
                    CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                } else {
                    #if USE_FILEDB
                    if (UI_GetData(FL_IsUseFileDB))
                    {
                       if (FileSys_ScanDir("A:\\DCIM\\",Filesys_dirCB,FALSE)==FST_STA_OK)
                       {
                           CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                       } else {
                          CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                       }
                    }
                    #else
                    CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                    #endif
                }
            if (CheckStorageErr == TRUE)
            //#NT#2013/1/28#Philex Lin - end
            {
                gMovData.State= MOV_ST_WARNING_MENU;
                gMovData.SysTimeCount = 0;
                return NVTEVT_CONSUME;
            }
            if(GetBatteryLevel() == BATTERY_EXHAUSTED)
            {
                debug_err(("UIFlowWndMovie_OnExeRecord: Battery is too low!\r\n"));
                return NVTEVT_CONSUME;
            }
            if (FlowMovie_GetSelfTimerID() != NULL_TIMER)
            {
                FlowMovie_StopRecSelfTimer();
                return NVTEVT_CONSUME;
            }
            #if 0
            if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
            {
                g_uiRecordIngMotionDet = TRUE;
            } else {
                g_uiRecordIngMotionDet = FALSE;
            }
            #endif

            // Isiah, implement YUV merge mode of recording func.
            if(FlowMovie_RecGetYUVMergeMode()) // Change IPL to movie record mode.
            {
                IPL_SLEEP_INFO Info;


                Movie_IPLChangeCB(MEDIAREC_IPLCHG_VIDEO, 0);
                DBG_DUMP("Changed IPL to movie record mode\r\n");

                Info.Id = 0;
                IPL_SetCmd(IPL_SET_SLEEP, (void *)&Info);
                IPL_WaitCmdFinish();
            }
			Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO, 1,  SysGetFlag(FL_MOVIE_AUDIO));
            UISound_Play(DEMOSOUND_SOUND_KEY_TONE);
            FlowMovie_StartRec();
            // start USB detect timer again
            if (g_ACPlug == TRUE)
                SxTimer_SetFuncActive(SX_TIMER_DET_USB_ID, TRUE);
            }
            break;
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM: // Isiah, implement YUV merge mode of recording func.
            if (FlowMovie_GetRecCurrTime() >= 1 || FlowMovie_RecGetYUVMergeMode() ||
                (SysGetFlag(FL_MOVIE_TIMELAPSE_REC) != MOVIE_TIMELAPSEREC_OFF))
            {
                // Mask key during movie stop flow.
                Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
                Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
                FlowMovie_StopRec();
                FlowMovie_IconHideLock();
                UISound_Play(DEMOSOUND_SOUND_KEY_TONE);
                // update ui window icon
                FlowMovie_UpdateIcons(TRUE);

                if (uiState==UIFlowWndMovie_Restart_Rec)
                {
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                } else {
                    #if 0
                    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
                    {
                        if (g_uiRecordIngMotionDet == TRUE)
                        {
                            g_uiRecordIngMotionDet = FALSE;
                        }
                    }
                    #endif
                }
            }
            break;
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_SHUTTER2,paramNum,paramArray);
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        if (0)//((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
        {
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            return NVTEVT_PASS;
        }
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            /* set Digital Zoom interface */
            UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

            gMovData.State |= MOV_ST_ZOOM;
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_IN, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

INT32 UIFlowWndMovie_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomOut][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
             /* set Digital Zoom interface */
             UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

             gMovData.State |= MOV_ST_ZOOM;
             Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_OUT, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

void UIFlowWndMovie_Initparam(void)
{
#if USE_FILEDB
    if (UI_GetData(FL_IsUseFileDB))
    {
       Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FILEID_RESET,0);
    }
#endif
    // The same effect as Photo mode
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_WB,                  1,  SysGetFlag(FL_WB));

    // The other settings
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,               1,  MOVIE_COLOR_NORMAL);

    /* Video resolution setting must be set after other IQ settings */
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIESIZE,           1,  SysGetFlag(FL_MOVIE_SIZE));
    ////Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_IMAGE_RATIO,         1,  SysGetFlag(FL_MOVIE_SIZE));

    /* Cyclic recording/record with mute or sound/DateImptint/Motion Detect */
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_CYCLIC_REC,          1,  SysGetFlag(FL_MOVIE_CYCLIC_REC));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOTION_DET,          1,  SysGetFlag(FL_MOVIE_MOTION_DET));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_DATE_IMPRINT,  1,  SysGetFlag(FL_MOVIE_DATEIMPRINT));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO,         1,  SysGetFlag(FL_MOVIE_AUDIO));
    Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_EV, 1, SysGetFlag(FL_EV));
	
    #if (_GYRO_EXT_==_GYRO_EXT_NONE_)
    SysSetFlag(FL_MovieMCTFIndex, MOVIE_MCTF_ON); // forced enable MCTF
    #else
    SysSetFlag(FL_MovieMCTFIndex, MOVIE_MCTF_OFF); // forced disable MCTF
    #endif
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_MCTF,          1,  SysGetFlag(FL_MovieMCTFIndex));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_GSENSOR,             1,  SysGetFlag(FL_GSENSOR));
}

//BOOL bUI_FirstOpen = FALSE;

INT32 UIFlowWndMovie_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiUsbType;
    TurnOnKEY_BACKLIGHTLed();
    Display_SetEnable(LAYER_VDO1, TRUE);

    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
    /* Init window key mask variables & set key and key released mask */
    g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
    g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyPress);
    SxTimer_SetFuncActive(SX_TIMER_DET_TV_ID, TRUE); //jacky lan

    UIFlowWndMovie_Initparam();
    //Ux_OpenWindow(&UIFlowWndWaitMomentCtrl,1,UIFlowWndWaitMoment_StatusTXT_Msg_STRID_PLEASE_WAIT);
    //        BKG_PostEvent(NVTEVT_BKW_FORMAT_NAND);
    FlowMovie_UpdateIcons(TRUE);
    KeyScan_EnableMisc(TRUE);
    FlowMovie_IconHideSpeed();
    if(UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE)
    {
       Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
    }

    // update g_uiRecordIngMotionDet flag
    if (gUIMotionDetTimerID==NULL_TIMER)
    {
        gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
    }

    if (g_uiDateTimerID == NULL_TIMER)
    {
        g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
    }

    // delete empty folder
    #if (USE_FILEDB==DISABLE)
    UIFlowWndMovie_DeleteEmptyFolder();
    #endif

    #if (GSENSOR_FUNCTION == ENABLE)
    GSensor_open();
    #endif
    LED_TurnOnLED(KEYSCAN_LED_GREEN);

   GxLED_SetCtrl(KEYSCAN_LED_GREEN,SET_TOGGLE_LED,FALSE);
   if(Get_TV_REC_status())
    {
    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
    Set_TV_REC_status(FALSE);
    }

    
    //uart_write(pBuffer_3,sizeof(pBuffer_1));
    
	//if(GxCustom_IsDCPowerON())
	//	{
	//	Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
	//	GxLED_SetCtrl(KEYSCAN_LED_GREEN,SET_TOGGLE_LED,TRUE);
	//	}
    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        if (FlowMovie_GetRecCurrTime() <= 1)
        {
            Delay_DelayMs(1000);
        }
        FlowMovie_StopRec();
        Ux_SendEvent(&UIFlowWndMovieCtrl,NVTEVT_CB_MOVIE_FINISH,0);
        break;
    }

    g_bRedLEDOn = FALSE;
    //KeyScan_TurnOffLED(KEYSCAN_LED_RED);

    if (gUIMotionDetTimerID!=NULL_TIMER)
    {
        GxTimer_StopTimer(&gUIMotionDetTimerID);
    }

    if (g_uiDateTimerID != NULL_TIMER)
    {
        GxTimer_StopTimer(&g_uiDateTimerID);
    }

    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiSoundMask;

    uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
        switch(gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_VIEW|MOV_ST_ZOOM:
            // stope timer when entering menu
            if (gUIMotionDetTimerID!=NULL_TIMER)
            {
                GxTimer_StopTimer(&gUIMotionDetTimerID);
            }

            if (g_uiDateTimerID != NULL_TIMER)
            {
                GxTimer_StopTimer(&g_uiDateTimerID);
            }
            // enable shutter2 sound (shutter2 as OK key in menu)
            uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
            uiSoundMask |= FLGKEY_SHUTTER2;
            Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

            Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
            // Set Tab menu to Movie menu
            TM_SetMenu(&gMovieMenu);
            // Open common mix (Item + Option) menu
            Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
            gMovData.State = MOV_ST_MENU;
            break;
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_MENU,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
//    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiEV;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_VIEW:
            case MOV_ST_VIEW|MOV_ST_ZOOM:
                uiEV = SysGetFlag(FL_EV);
                if (uiEV==EV_N20)
                {
                    SysSetFlag(FL_EV,EV_P20);
                } else {
                    SysSetFlag(FL_EV,++uiEV);
                }
                Ux_SendEvent(&CustomMovieObjCtrl,NVTEVT_EXE_MOVIE_EV,1, SysGetFlag(FL_EV));
                FlowMovie_IconDrawEV(&UIFlowWndMovie_StatusICN_EVCtrl);
            break;
            case MOV_ST_REC:
                if(SysGetFlag(FL_MOVIE_CYCLIC_REC) != MOVIE_CYCLICREC_OFF && FlowMovie_GetRecCurrTime() >= 1)
                {
                    #if (0)//(PRJ == APC3)
                        g_bSpeLockFun = TRUE;
                        FlowMovie_StopRec();
                        Ux_SendEvent(pCtrl,NVTEVT_CB_MOVIE_FINISH,1,UIFlowWndMovie_Restart_Rec);
                    #endif
                }
            break;
         }
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_REC:
            case MOV_ST_REC|MOV_ST_ZOOM:
                {
                    UINT32 uiJpegWidth, uiJpegHeight, uiDAR, uiMovieSize;

                    FlowMovie_DrawPIM(TRUE);
                    {
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
                        uiJpegWidth = GetMovieSizeWidth(uiMovieSize);
                        uiJpegHeight = GetMovieSizeHeight(uiMovieSize);
                        uiDAR = GetMovieDispAspectRatio(uiMovieSize);
                    }
                    if (uiDAR == VIDENC_DAR_16_9)
                    {
                        uiJpegWidth = (uiJpegHeight * 16) / 9;
                    }
                    Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, uiJpegWidth, uiJpegHeight);
                }
                break;
         }
         break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiSoundMask;
    /*
    if(paramArray[0] == Wifi_Start_wait)
        {
            #if (WIFI_AP_FUNC==ENABLE)
            Ux_OpenWindow(&UIMenuWndWiFiModuleLinkCtrl,0);//show link fail
            #endif
        }
    else if(paramArray[0] == Wifi_wait_Link)
        {
        Ux_OpenWindow(&UIMenuWndWiFiMobileLinkOKCtrl, 0);
        }
        */
    switch (gMovData.State)
    {
    case MOV_ST_WARNING_MENU:
         if(paramNum > 0)
            {
                if(paramArray[0] == NVTRET_ENTER_MENU)
                {
                    /* Create Menu window */
                    gMovData.State = MOV_ST_MENU;
                    TM_SetMenu(&gMovieMenu);
                    Ux_OpenWindow(&MenuCommonItemCtrl, 0);
                    return NVTEVT_CONSUME;
                }
            }
            gMovData.State = MOV_ST_VIEW;
        break;

    case MOV_ST_MENU:
        // disable shutter2 sound
        uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
        uiSoundMask &= ~FLGKEY_SHUTTER2;
        Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

         g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
         g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
         Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
         Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
         FlowMovie_UpdateIcons(TRUE);

         // start timer again when exiting menu
         if (gUIMotionDetTimerID==NULL_TIMER)
         {
           gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
         }

         if (g_uiDateTimerID == NULL_TIMER)
         {
           g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
         }

         gMovData.State = MOV_ST_VIEW;
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomIn(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomOut(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
        if(gMovData.State==MOV_ST_REC)
        {
            FlowMovie_StopRec();
            //Delay_DelayMs(500);
        }
        GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_DELAY_CLOSE_TIMER, ONE_SHOT);
        break;
        }
    return NVTEVT_PASS;
    //return UIFlowWndMovie_OnExeZoomIn(pCtrl, paramNum, paramArray);
    
}
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FORCETO_PLAYBACK_MODE,0);
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 static volatile BOOL bBatteryOn = FALSE;

    UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl,STATE_CURITEM,GetBatteryLevel());
    if (0)//(KeyScan_IsACIn())
    {
        bBatteryOn = !bBatteryOn;
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,bBatteryOn);
    } else {
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,TRUE);
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiSelect = 0;

    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_EXE_CHANGEDSCMODE,1,DSCMODE_CHGTO_NEXT);
        break;

        case MOV_ST_REC:
	      case MOV_ST_REC|MOV_ST_ZOOM:
	        uiSelect = SysGetFlag(FL_MOVIE_AUDIO);

		if (uiSelect == MOVIE_AUDIO_OFF)
		{
	           SysSetFlag(FL_MOVIE_AUDIO,MOVIE_AUDIO_ON);
		    UIMovRecObj_SetData(RECMOVIE_AUD_VOLUME, RECMOVIE_AUD_ON);		
		}
		else
		{
	           SysSetFlag(FL_MOVIE_AUDIO,MOVIE_AUDIO_OFF);	
		    UIMovRecObj_SetData(RECMOVIE_AUD_VOLUME, RECMOVIE_AUD_OFF);	
		}		
	        FlowMovie_IconDrawAudioOnOff(&UIFlowWndMovie_StatusICN_AudioCtrl);
		  break;
        break;

    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiFolderId, uiFileId;
    BOOL    CheckStorageErr;
    //UINT32  gUIAviRecMaxTime;

    switch (gMovData.State)
    {
      case MOV_ST_REC:
      case MOV_ST_REC|MOV_ST_ZOOM:
            #if 0
            if(UIStorageCheck(STORAGE_CHECK_FULL, &(gUIAviRecMaxTime)) != TRUE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);
            }
            #endif
            gMovData.State = MOV_ST_VIEW;
            #if 0
            g_uiRecordIngMotionDet = FALSE;
            #endif
            //#NT#2012/10/23#Philex Lin - begin
            // enable auto power off/USB detect timer
            KeyScan_EnableMisc(TRUE);
            //#NT#2012/10/23#Philex Lin - end
            FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
            UxCtrl_SetShow(&UIFlowWndMovie_PanelCtrl,FALSE);

            //if (FlowMovie_ChkDrawStoreFullFolderFull() == FALSE)
            if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
            {
                CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
            } else {
                CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
            }
            if (CheckStorageErr == FALSE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);

                FlowMovie_UpdateIcons(TRUE);
                Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
            }
            break;

        //The flow here may be only for APC3 stop record than lock file function.
        //To be careful that gMovData have changed in UIFlowMovie_Stop.
        case MOV_ST_VIEW:
            #if (0)//(PRJ == APC3)
            if (paramNum)
            {
                if (paramArray[0]==UIFlowWndMovie_Restart_Rec)
                {
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                }
            }
            #endif
            // Enable key if user pressed shutter2 key to stop recording.
            Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
            break;
    }
	if(UIFlowWndMovie_IsGsensorTrig()==TRUE)
	{
		UIFlowWndMovie_SetGsensorTrigFlag(FALSE);
	}
    FlowMovie_IconHideLock();
    GxLED_SetCtrl(KEYSCAN_LED_GREEN,TURNON_LED,TRUE);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        UxCtrl_SetShow(&UIFlowWndMovie_PanelCtrl,!UxCtrl_IsShow(&UIFlowWndMovie_PanelCtrl));
        FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
		if(UxCtrl_IsShow(&UIFlowWndMovie_PanelCtrl))
			GxLED_SetCtrl(KEYSCAN_LED_GREEN,TURNON_LED,TRUE);
		else
			GxLED_SetCtrl(KEYSCAN_LED_GREEN,TURNON_LED,FALSE);
        if (paramNum)
        {
            FlowMovie_SetRecCurrTime(paramArray[0]);
        }
        FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
        if (UxCtrl_IsShow(&UIFlowWndMovie_StaticIcon_PIMCCtrl))
            FlowMovie_DrawPIM(FALSE);
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    //UINT32  uiAviRecMaxTime;
    UINT32  uiFolderId, uiFileId;
    BOOL    CheckStorageErr,isNeedRecordAgain=FALSE;


    if (gMovData.State&MOV_ST_REC)
    {
        isNeedRecordAgain = TRUE;
    } else {
        isNeedRecordAgain = FALSE;
    }
    FlowMovie_StopRec();
    //#NT#2012/10/23#Philex Lin - begin
    //enable auto power off/USB detect timer
    KeyScan_EnableMisc(TRUE);
    //#NT#2012/10/23#Philex Lin - end

    if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
    {
        CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
    } else {
        CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
    }

    if (CheckStorageErr == FALSE) // storage may be not full, but reach the condition of FAT file size limit
    {
        gMovData.State= MOV_ST_VIEW;
        DCF_GetNextID(&uiFolderId, &uiFileId);
        SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
        SysSetFlag(FL_DCF_FILE_ID, uiFileId);
        // Need to record again because strage does not reach full !!
        if (TRUE==isNeedRecordAgain)
        {
            Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
        }
        //Save_MenuInfo();

        //[TO DO]: should update OSD icons in this case?
    }
    else // storage is really full
    {
        gMovData.State= MOV_ST_WARNING_MENU;
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL,FLOWWRNMSG_TIMER_2SEC);
    }
FlowMovie_IconHideLock();
    FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
GxLED_SetCtrl(KEYSCAN_LED_GREEN,TURNON_LED,TRUE);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieWrError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    if ((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM)))
    {
        FlowMovie_StopRec();
        if (UI_GetData(FL_CardStatus) == CARD_LOCKED)
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_3SEC);
            return NVTEVT_CONSUME;
        }
        else
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR,FLOWWRNMSG_TIMER_3SEC);
            return NVTEVT_CONSUME;
        }
    }
    else
    {
        Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // trigger re-start encoding
    #if 0
    return UIFlowWndMovie_OnExeRecord(pCtrl, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
    #else
    Movie_SetSDSlow(TRUE);
    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
    return NVTEVT_CONSUME;
    #endif
}
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    //FlowMovie_StopRec();
    KeyScan_EnableMisc(TRUE);
    //gMovData.State = MOV_ST_VIEW;
    gMovData.State= MOV_ST_WARNING_MENU;
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL,FLOWWRNMSG_TIMER_2SEC);
    FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
    return NVTEVT_CONSUME;
}
#if 0
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    ide_enable_video(IDE_VIDEOID_1);
    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_IconDrawDZoom(&UIFlowWndMovie_Zoom_StaticCtrl);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiEvent;

    if (paramNum>0)
    {
        uiEvent = paramArray[0];
        if (uiEvent != NVTEVT_ALGMSG_PREVIEW_STABLE)
            return NVTEVT_CONSUME;
    } else {
        return NVTEVT_CONSUME;
    }

    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    g_PreviewStable = TRUE;
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_UpdateIcons(TRUE);

    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyRelease);
    return NVTEVT_CONSUME;
}
#if (GPS_FUNCTION == ENABLE)
inline static void  UIFlowWndMovie_UpdateSpeedData(void)
{
/*
 RMCINFO RMCInfo;
 GPSRec_GetRMCDate(&RMCInfo);
 memcpy(&(gpsdata.rmcinfo),&RMCInfo,sizeof(RMCINFO));
 */

    	static UINT32 uiGPSCounter = 0;
    	static UINT32 uiGPSCounter2 = 0;
	static BOOL changespeeddata = FALSE;
    	static UINT32 i;	
    	static UINT32 GPS_Second_Pre=0xff;
       UINT32 day = 0, month = 0, year = 0, hour = 0, min = 0, sec = 0;
	UINT8	uiTimeZone = 0;
	UINT32 Days;
       RMCINFO RMCInfo2;
    
   	if(DetGPS_IO())//if (SysGetFlag(FL_MOVIE_GPS)==GPS_ON)//if(!DetGPS_IO())
   	{
   	       SysSetFlag(FL_MOVIE_GPS,GPS_ON);
      		GPSRec_GetRMCDate(&RMCInfo);      		
		if (GPSRec_CheckData() == TRUE)
		{
                    uiSpeedKM = (UINT32)(RMCInfo.Speed*1.852);
                    //uiSpeed = (UINT32)(RMCInfo.Speed*1.852/1.6093);//英里每小时                        	 
                    //RMCInfo.Speed=uiSpeedKM;                         
                    if (UI_GetData(FL_AUTO_UPDATE_TIME) != AUTO_UPDATE_TIME_OFF)
                    {
                        if(gbUpdteGPSTime==FALSE)
                        {
                            if(uiGPSCounter>5)
                            {
                                gbUpdteGPSTime=TRUE;
                                UIFlowwndMovieUpdateGPSTime();
                            }
                            else
                            {
                                   uiGPSCounter++;
                            }
                        }
                    }
                    memcpy(&RMCInfo2, &RMCInfo, sizeof(RMCINFO));
                    RMCInfo2.Speed *= 1.852;
                    memcpy(&(gpsdata.rmcinfo),&RMCInfo2,sizeof(RMCINFO));
                    //uiSpeed = (UINT32)(RMCInfo.Speed*1.852);
                    FlowMovie_IconDrawSpeed();                             

			if (GPS_Second_Pre != RMCInfo.Second)
			{
				//debug_err(("UIFlowWndMovie_Update_Speed... GPS_Second_Pre != RMCInfo.Second\r\n"));
				UxState_SetData(&UIFlowWndMovie_Status_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Status_GPS_ICON_GPS_OK);						
				GPS_Second_Pre = RMCInfo.Second;	
				uiGPSCounter2=0;
			}
			else
			{
				uiGPSCounter2++;
				if(uiGPSCounter2>5)
				{
					//debug_err(("UIFlowWndMovie_Update_Speed... GPS_Second_Pre == RMCInfo.Second==========\r\n"));
					gbUpdteGPSTime=FALSE;
                                   GPSRec_Reset();
					FlowMovie_IconHideSpeed();
            				UxState_SetData(&UIFlowWndMovie_Status_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Status_GPS_ICON_GPS_NC);			
	
				}
			}		 
		}
		else
		{			
			FlowMovie_IconHideSpeed();
			UxState_SetData(&UIFlowWndMovie_Status_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Status_GPS_ICON_GPS_NC);									
		}
            UxCtrl_SetShow(&UIFlowWndMovie_Status_GPSCtrl,TRUE);
   	    }
    else
    {
        SysSetFlag(FL_MOVIE_GPS,GPS_OFF);
        uiGPSCounter=0;
        uiGPSCounter2=0;
        GPS_Second_Pre=0xff;
        gbUpdteGPSTime=FALSE;
        UxState_SetData(&UIFlowWndMovie_Status_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Status_GPS_ICON_GPS_NS);	
        UxCtrl_SetShow(&UIFlowWndMovie_Status_GPSCtrl,TRUE);
    }
}
#endif


INT32 UIFlowWndMovie_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiEvent;
    uiEvent = paramNum ? paramArray[0] : 0;
    static int cnt = 0;


    switch(uiEvent)
    {
    case NVTEVT_05SEC_TIMER:                   
        if(!MediaRec_IsRecording())
            {
            GxLED_SetCtrl(KEYSCAN_LED_GREEN,SET_TOGGLE_LED,FALSE);
            GxLED_SetCtrl(KEYSCAN_LED_GREEN,TURNON_LED,TRUE);
            }
            if(g_bgsensor)
                {
                if(cnt< 6)
                    {
                    cnt++;
                    if(cnt%2 == 0)
                    FlowMovie_IconHideGsensor();
                    else
                        FlowMovie_IconDrawGsensor();
                    
                    }
                else
                        FlowMovie_IconDrawGsensor();

                
                }
            else
                {
                cnt = 0;
                }
        #if 0//(AUTO_WIFI==ENABLE)
        {
            static BOOL autoWifi = FALSE;

            if(!autoWifi)
            {
                Ux_OpenWindow(&UIMenuWndWiFiWaitCtrl, 0);
                BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
                autoWifi = TRUE;
            }
        }
        #endif 
        // Motion Detect function
        if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
        {
            static UINT32  uiMotionDetGo = 0;
            static UINT32  uiMotionDetStop = 0;

            if (MD_Process()==TRUE)
            {
                 uiMotionDetGo++;
                 if (uiMotionDetGo>=2)
                 {
                 UxState_SetData(&UIFlowWndMovie_Status_MotionDetCtrl,STATE_CURITEM,1);
                    uiMotionDetStop=0;
                    if (!((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM))))
                    {
                        // reset uiMotionDetGo
                        uiMotionDetGo = 0;
                        // press enter key to record video
                        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                        
                        
                    }
                 }
            } else {
                uiMotionDetStop++;
                if(uiMotionDetStop<=4)
                    {
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_MotionDetCtrl, uiMotionDetStop%2);
                    }
                else
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_MotionDetCtrl, TRUE);
                if (uiMotionDetStop>=2) // 1 sec
                {
                    uiMotionDetGo=0;
                }
               if (uiMotionDetStop>=60) // 30 Sec// if (uiMotionDetStop>=20) // 10 Sec
                {
                    uiMotionDetStop = 0;
                    switch(gMovData.State)
                    {
                      case MOV_ST_REC:
                      case MOV_ST_REC|MOV_ST_ZOOM:
                        // stop recording
                        if (FlowMovie_GetRecCurrTime() >= 1)
                        {
                            FlowMovie_StopRec();
                            UxState_SetData(&UIFlowWndMovie_Status_MotionDetCtrl,STATE_CURITEM,0);
                            if ( FALSE == AE_Wait_Stable(3, 60) )
                                DBG_ERR("Motion Detection: AE do not stable\r\n");
                        }
                        break;
                    }
                }
            }
        }

        //get GPS/GSensor Data
        //#NT#2013/3/20#Philex Lin-begin
        #if (GPS_FUNCTION == ENABLE)
        UIFlowWndMovie_UpdateSpeedData();
        #endif
		//UIFlowWndMovie_Update_Gsensor();	
        //#NT#2013/3/20#Philex Lin-end
        break;

    case NVTEVT_1SEC_TIMER:
        FlowMovie_OnTimer1SecIndex();
        // Isiah, implement YUV merge mode of recording func.
        if(MediaRec_IsRecording() && FlowMovie_RecGetYUVMergeMode())
        {
            MEDIAREC_READYBUF_INFO readyInfo;
            IPL_IME_BUF_ADDR CurInfo;
            IPL_SLEEP_INFO Info;

            FlowMovie_RecYUVMergeCounterInc();
            if(FlowMovie_RecGetYUVMergeRecCounter() < FlowMovie_RecGetYUVMergeRecInterval())
            {
                break;
            }
            else // reset counter;
            {
                FlowMovie_RecSetYUVMergeRecCounter(0);
            }

            Info.Id = 0;
            IPL_SetCmd(IPL_SET_WAKEUP, (void *)&Info);
            IPL_WaitCmdFinish();
            // Wait until AE/AWB are stable.
            IPC_WaitVD(FALSE,IPL_ID_1);
            IPC_WaitVD(FALSE,IPL_ID_1);
            IPC_WaitVD(FALSE,IPL_ID_1);

            CurInfo.Id = IPL_ID_1;
            IPL_GetCmd(IPL_GET_IME_CUR_BUF_ADDR, (void *)&CurInfo);

            readyInfo.y = CurInfo.ImeP1.PixelAddr[0];
            readyInfo.cb = CurInfo.ImeP1.PixelAddr[1];
            //readyInfo.cr = CurInfo.ImeP1.PixelAddr[2];
            readyInfo.cr = CurInfo.ImeP1.PixelAddr[1]; // UV pack
            readyInfo.y_lot = CurInfo.ImeP1.Ch[0].LineOfs;
            readyInfo.uv_lot = CurInfo.ImeP1.Ch[1].LineOfs;
            readyInfo.uiBufID = CurInfo.ImeP1.PixelAddr[2]; // for IME ready buffer check
            MediaRec_GiveYUV(&readyInfo);

            // Wait 40 ms to ensure encode finished.
            Delay_DelayMs(40);

            Info.Id = 0;
            IPL_SetCmd(IPL_SET_SLEEP, (void *)&Info);
            IPL_WaitCmdFinish();
        }
        else if (g_PreviewStable_Record == FALSE)
        {
            if ((g_ACPlug==TRUE)&&(g_PreviewStable == TRUE))
            {
                g_PreviewStable_Record = TRUE;
                //Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
            }
        }
        break;

        case NVTEVT_DELAY_CLOSE_TIMER:

        TurnOnWifiLed();
        Display_SetEnable(LAYER_VDO1, FALSE);
        Ux_OpenWindow(&UIMenuWndWiFiWaitCtrl, 0);
        BKG_PostEvent(NVTEVT_BKW_WIFI_ON);            
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_TIMER,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnACPlug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_ACPlug = TRUE;
    // start record if receiving preview stable event
    if ((g_PreviewStable == TRUE)&&(g_PreviewStable_Record == FALSE))
    {
        g_PreviewStable_Record = TRUE;
        switch(gMovData.State)
	       {
	      		case MOV_ST_VIEW:
	      		case MOV_ST_VIEW|MOV_ST_ZOOM:  
				
	    			Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
				break;
			default:
				break;	    	
	    	}
        if(UI_GetData(FL_WIFI_AUTO_RECORDING) == WIFI_AUTO_RECORDING_ON)
        {
           // Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
        }
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnACUnplug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_ACPlug = FALSE;
    //Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_GsensorTrig(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
     if(g_bgsensor==FALSE)
     {
	g_bgsensor = TRUE;     
	debug_msg("%s..\r\n",__func__);	
    if(gMovData.State != MOV_ST_REC)
        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
        FlowMovie_IconDrawLock();
	MediaRec_SetCrash();
     }
    return NVTEVT_CONSUME;
}

//----------------------UIFlowWndMovie_Static_cameraCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_camera)
EVENT_END

//----------------------UIFlowWndMovie_Status_CyclicRecCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_CyclicRec)
EVENT_END

//----------------------UIFlowWndMovie_Status_MotionDetCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MotionDet)
EVENT_END

//----------------------UIFlowWndMovie_Status_batteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_battery)
EVENT_END

//----------------------UIFlowWndMovie_YMD_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_YMD_Static)
EVENT_END

//----------------------UIFlowWndMovie_HMS_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Static)
EVENT_END

//---------------------UIFlowWndMovie_PanelCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel)
CTRL_LIST_END

//----------------------UIFlowWndMovie_PanelCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel)
EVENT_END

//----------------------UIFlowWndMovie_Status_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Storage)
EVENT_END

//----------------------UIFlowWndMovie_Static_timeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_time)
EVENT_END

//----------------------UIFlowWndMovie_Static_maxtimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_maxtime)
EVENT_END

//----------------------UIFlowWndMovie_Static_resolutionCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_resolution)
EVENT_END

//----------------------UIFlowWndMovie_Zoom_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Zoom_Static)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndMovie_Status_HDRCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_HDR)
EVENT_END

//----------------------UIFlowWndMovie_StaticIcon_PIMCCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticIcon_PIMC)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_AudioCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_Audio)
EVENT_END
//----------------------UIFlowWndMovie_Status_GPSCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_GPS)
EVENT_END

//----------------------UIFlowWndMovie_Status_GsensorCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Gsensor)
EVENT_END
//----------------------UIFlowWndMovie_StaticTXT_SpeedCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticTXT_Speed)
EVENT_END
//----------------------UIFlowWndMovie_Static_LockCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_Lock)
EVENT_END
//---------------------UIFlowWndMovie_LDWS_FrameCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_LDWS_Frame)
CTRL_LIST_END

extern LDWS_NVT_INFO g_LwdsInfo; 

int GetLDWSDeparture_dirInfo(void )
{
    if(g_LwdsInfo.Departure_dir < 0  || g_LwdsInfo.Departure_dir > 2)
    return 0;
    else
    return g_LwdsInfo.Departure_dir;
}

//----------------------UIFlowWndMovie_LDWS_FrameCtrl Event---------------------------
INT32 UIFlowWndMovie_LDWS_Frame_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie_LDWS_Frame)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndMovie_LDWS_Frame_OnRedraw)
EVENT_END



INT32 UIFlowWndMovie_LDWS_Frame_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    int x1=0, y1=0, x2=0, y2=0;
    UIScreen ScreenObj = *paramArray;
    LDWS_OSD_COORDINATE *pLdwsOsdCoord = NULL;
    if(SysGetFlag(FL_MOVIE_SIZE) == MOVIE_SIZE_WVGA  ||SysGetFlag(FL_MOVIE_SIZE) == MOVIE_SIZE_VGA 
		|| UI_GetData(FL_MOVIE_LDWS) == MOVIE_LDWS_OFF)
        {
        return NVTEVT_CONSUME;
        }
    //debug_msg("^M%s: ScreenObj = 0x%x\r\n", __func__, ScreenObj);
    if (gMovData.State == MOV_ST_REC)
    {
        pLdwsOsdCoord = (LDWS_OSD_COORDINATE *)FlowMovie_GetLdwsOsdIno();

        GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(2), FILLSTYLE_FILL);
        GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);;

        // draw ROI region
        if (g_LwdsInfo.Failure == LDWS_FAILURE_TRUE)
        {
            GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
        }
        else
        {
            GxGfx_SetShapeColor(CLRID_IDX_BLACK, CLRID_IDX_BLACK, NULL);
        }
        GxGfx_FrameRect(((DC**)ScreenObj)[GxGfx_OSD], pLdwsOsdCoord->ROIx1, pLdwsOsdCoord->ROIy1, pLdwsOsdCoord->ROIx4, pLdwsOsdCoord->ROIy4);

        // draw vanishing line location
        GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pLdwsOsdCoord->VPx1, pLdwsOsdCoord->VPy1, pLdwsOsdCoord->VPx2, pLdwsOsdCoord->VPy2);

        // draw lane detection result
        if (g_LwdsInfo.Failure == LDWS_FAILURE_FALSE)
        {
            if (g_LwdsInfo.Departure_dir == LDWS_DEPARTURE_LEFT)
            {
                GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
            }else{
                GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
            }
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pLdwsOsdCoord->LaneLx1, pLdwsOsdCoord->LaneLy1, pLdwsOsdCoord->LaneLx2, pLdwsOsdCoord->LaneLy2); // left lane

            if (g_LwdsInfo.Departure_dir == LDWS_DEPARTURE_RIGHT)
            {
                GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
            }else{
                GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
            }
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pLdwsOsdCoord->LaneRx1, pLdwsOsdCoord->LaneRy1, pLdwsOsdCoord->LaneRx2, pLdwsOsdCoord->LaneRy2); // right lane
            if(UI_GetData(FL_MOVIE_LDWS) == MOVIE_LDWS_ON  && UI_GetData(FL_MOVIE_LDWS_BEEP))
                {
                    if(g_LwdsInfo.Departure_dir == LDWS_DEPARTURE_LEFT ||g_LwdsInfo.Departure_dir == LDWS_DEPARTURE_RIGHT)
        		{
        		Set_LDWS_BEEP(TRUE);
        		//timer_pausePlay(DetLDWS_BEEPTimerID,TIMER_STATE_PLAY);
        		}
        		else
        		{
        		Set_LDWS_BEEP(FALSE);
        		//timer_pausePlay(DetLDWS_BEEPTimerID,TIMER_STATE_PAUSE);
        		//GPIO_Set_LDWS_BEEP(FALSE);
        		}
                }
        }
        else
        Set_LDWS_BEEP(FALSE);
        
    }

    return NVTEVT_CONSUME;
}

#if 0
void open_LDWS_BEEP_Timer(void)
{
    if (timer_open((UINT *)&DetLDWS_BEEPTimerID, System_LDWS_BEEP) != E_OK)
        return;
    timer_cfg(DetLDWS_BEEPTimerID, 434, TIMER_MODE_FREE_RUN | TIMER_MODE_ENABLE_INT, TIMER_STATE_PLAY);
	timer_pausePlay(DetLDWS_BEEPTimerID,TIMER_STATE_PLAY);
	//GPIO_Set_LDWS_BEEP(FALSE);
}


void System_LDWS_BEEP(UINT32 uiEvent)
{
//debug_msg("^G ===   System_LDWS_BEEP  uiEvent:%ld\r\n",uiEvent);
if(GPIO_Get_LDWS_BEEP())
	GPIO_Set_LDWS_BEEP(FALSE);
	else
		GPIO_Set_LDWS_BEEP(TRUE);
}
#endif
